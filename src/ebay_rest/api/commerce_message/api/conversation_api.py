# coding: utf-8

"""
    M2M Public API Service

    This API allows eBay sellers to send, retrieve, and manage messages.  # noqa: E501

    OpenAPI spec version: 1.0.0
    
    Generated by: https://github.com/swagger-api/swagger-codegen.git
"""

from __future__ import absolute_import

import re  # noqa: F401

# python 2 and python 3 compatibility library
import six

from ...commerce_message.api_client import ApiClient


class ConversationApi(object):
    """NOTE: This class is auto generated by the swagger code generator program.

    Do not edit the class manually.
    Ref: https://github.com/swagger-api/swagger-codegen
    """

    def __init__(self, api_client=None):
        if api_client is None:
            api_client = ApiClient()
        self.api_client = api_client

    def bulk_update_conversation(self, content_type, **kwargs):  # noqa: E501
        """bulk_update_conversation  # noqa: E501

        This method can be used to update the <b>conversationStatus</b> of up to 10 conversations.<br><br>The <b>conversationId</b>, existing <b>conversationType</b>, and updated <b>conversationStatus</b> for each conversation to modify are required in the <b>conversations</b> array.<br><br><div class=\"msgbox_important\"><p class=\"msgbox_importantInDiv\" data-mc-autonum=\"&lt;b&gt;&lt;span style=&quot;color: #dd1e31;&quot; class=&quot;mcFormatColor&quot;&gt;Important! &lt;/span&gt;&lt;/b&gt;\"><span class=\"autonumber\"><span><b><span style=\"color: #dd1e31;\" class=\"mcFormatColor\">Important!</span></b></span></span> Though it cannot be updated, the <b>conversationType</b> field is required for each conversation being updated.</p></div><br>If the updates were successful, the <b>conversationId</b> of each conversation will be returned with an associated <b>updateStatus</b> value of <code>SUCCESSFUL</code>.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.bulk_update_conversation(content_type, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str content_type: This header indicates the format of the request body provided by the client. Its value should be set to <b>application/json</b>. <br><br>For more information, refer to <a href=\"/api-docs/static/rest-request-components.html#HTTP\" target=\"_blank \">HTTP request headers</a>. (required)
        :param BulkUpdateConversationsRequest body:
        :return: BulkUpdateConversationsResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        if '_return_http_data_only' not in kwargs:  # ebay_rest patch
            kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.bulk_update_conversation_with_http_info(content_type, **kwargs)  # noqa: E501
        else:
            (data) = self.bulk_update_conversation_with_http_info(content_type, **kwargs)  # noqa: E501
            return data

    def bulk_update_conversation_with_http_info(self, content_type, **kwargs):  # noqa: E501
        """bulk_update_conversation  # noqa: E501

        This method can be used to update the <b>conversationStatus</b> of up to 10 conversations.<br><br>The <b>conversationId</b>, existing <b>conversationType</b>, and updated <b>conversationStatus</b> for each conversation to modify are required in the <b>conversations</b> array.<br><br><div class=\"msgbox_important\"><p class=\"msgbox_importantInDiv\" data-mc-autonum=\"&lt;b&gt;&lt;span style=&quot;color: #dd1e31;&quot; class=&quot;mcFormatColor&quot;&gt;Important! &lt;/span&gt;&lt;/b&gt;\"><span class=\"autonumber\"><span><b><span style=\"color: #dd1e31;\" class=\"mcFormatColor\">Important!</span></b></span></span> Though it cannot be updated, the <b>conversationType</b> field is required for each conversation being updated.</p></div><br>If the updates were successful, the <b>conversationId</b> of each conversation will be returned with an associated <b>updateStatus</b> value of <code>SUCCESSFUL</code>.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.bulk_update_conversation_with_http_info(content_type, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str content_type: This header indicates the format of the request body provided by the client. Its value should be set to <b>application/json</b>. <br><br>For more information, refer to <a href=\"/api-docs/static/rest-request-components.html#HTTP\" target=\"_blank \">HTTP request headers</a>. (required)
        :param BulkUpdateConversationsRequest body:
        :return: BulkUpdateConversationsResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['content_type', 'body']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method bulk_update_conversation" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'content_type' is set
        if ('content_type' not in params or
                params['content_type'] is None):
            raise ValueError("Missing the required parameter `content_type` when calling `bulk_update_conversation`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}
        if 'content_type' in params:
            header_params['Content-Type'] = params['content_type']  # noqa: E501

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api_auth']  # noqa: E501

        return self.api_client.call_api(
            '/bulk_update_conversation', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='BulkUpdateConversationsResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_conversation(self, conversation_id, conversation_type, **kwargs):  # noqa: E501
        """get_conversation  # noqa: E501

        This method can be used to retrieve messages within a specific conversation.<br><br>The <b>conversation_id</b> of the conversation for which to retrieve messages is required as path parameters, and the and <b>conversation_type</b> of the conversation is required as a query parameter.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_conversation(conversation_id, conversation_type, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str conversation_id: This path parameters specifies the unique identifier of the conversation that is to be retrieved.<br><br>Use the <a href=\"/api-docs/commerce/message/resources/conversation/methods/getConversations\" target=\"_blank\">getConversations</a> method to retrieve conversation ID values. (required)
        :param str conversation_type: This query parameter specifies the type of the conversation being retrieved.<br><br>This parameter is always required when using the this method.<br><br><b>Valid values:</b><ul><li><code>FROM_EBAY</code></li><li><code>FROM_MEMBERS</code></li></ul> (required)
        :param str limit: The maximum number of entries that can be returned on each page of the paginated response.<br><br>Use this parameter in conjunction with the <b>offset</b> parameter to control the pagination of the output. For example, if <b>offset</b> is set to <code>10</code> and <b>limit</b> is set to <code>10</code>, the call retrieves entries 11 through 20 from the result set.<br><br><span class=\"tablenote\"><b>Note:</b> This feature employs a zero-based list, where the first item in the list has an offset of <code>0</code>.</span><br>If this parameter is omitted, the default value is used.<br><br><b>Default:</b> 25<br><br><b>Maximum:</b> 50
        :param str offset: The number of reports to skip in the result set before returning the first entry in the paginated response.<br><br>Use this parameter in conjunction with the <b>limit</b> parameter to control the pagination of the output. For example, if <b>offset</b> is set to <code>0</code> and <b>limit</b> is set to <code>10</code>, the first page of the response will contain the first 10 entries from the complete list retrieved by the call.<br><br><span class=\"tablenote\"><b>Note:</b> This feature employs a zero-based list, where the first item in the list has an offset of <code>0</code>.</span><br>If this parameter is omitted, the default value is used.<br><br><b>Default:</b> 0
        :return: GetMessagesByConversationIdResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        if '_return_http_data_only' not in kwargs:  # ebay_rest patch
            kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_conversation_with_http_info(conversation_id, conversation_type, **kwargs)  # noqa: E501
        else:
            (data) = self.get_conversation_with_http_info(conversation_id, conversation_type, **kwargs)  # noqa: E501
            return data

    def get_conversation_with_http_info(self, conversation_id, conversation_type, **kwargs):  # noqa: E501
        """get_conversation  # noqa: E501

        This method can be used to retrieve messages within a specific conversation.<br><br>The <b>conversation_id</b> of the conversation for which to retrieve messages is required as path parameters, and the and <b>conversation_type</b> of the conversation is required as a query parameter.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_conversation_with_http_info(conversation_id, conversation_type, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str conversation_id: This path parameters specifies the unique identifier of the conversation that is to be retrieved.<br><br>Use the <a href=\"/api-docs/commerce/message/resources/conversation/methods/getConversations\" target=\"_blank\">getConversations</a> method to retrieve conversation ID values. (required)
        :param str conversation_type: This query parameter specifies the type of the conversation being retrieved.<br><br>This parameter is always required when using the this method.<br><br><b>Valid values:</b><ul><li><code>FROM_EBAY</code></li><li><code>FROM_MEMBERS</code></li></ul> (required)
        :param str limit: The maximum number of entries that can be returned on each page of the paginated response.<br><br>Use this parameter in conjunction with the <b>offset</b> parameter to control the pagination of the output. For example, if <b>offset</b> is set to <code>10</code> and <b>limit</b> is set to <code>10</code>, the call retrieves entries 11 through 20 from the result set.<br><br><span class=\"tablenote\"><b>Note:</b> This feature employs a zero-based list, where the first item in the list has an offset of <code>0</code>.</span><br>If this parameter is omitted, the default value is used.<br><br><b>Default:</b> 25<br><br><b>Maximum:</b> 50
        :param str offset: The number of reports to skip in the result set before returning the first entry in the paginated response.<br><br>Use this parameter in conjunction with the <b>limit</b> parameter to control the pagination of the output. For example, if <b>offset</b> is set to <code>0</code> and <b>limit</b> is set to <code>10</code>, the first page of the response will contain the first 10 entries from the complete list retrieved by the call.<br><br><span class=\"tablenote\"><b>Note:</b> This feature employs a zero-based list, where the first item in the list has an offset of <code>0</code>.</span><br>If this parameter is omitted, the default value is used.<br><br><b>Default:</b> 0
        :return: GetMessagesByConversationIdResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['conversation_id', 'conversation_type', 'limit', 'offset']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_conversation" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'conversation_id' is set
        if ('conversation_id' not in params or
                params['conversation_id'] is None):
            raise ValueError("Missing the required parameter `conversation_id` when calling `get_conversation`")  # noqa: E501
        # verify the required parameter 'conversation_type' is set
        if ('conversation_type' not in params or
                params['conversation_type'] is None):
            raise ValueError("Missing the required parameter `conversation_type` when calling `get_conversation`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'conversation_id' in params:
            path_params['conversation_id'] = params['conversation_id']  # noqa: E501

        query_params = []
        if 'conversation_type' in params:
            query_params.append(('conversation_type', params['conversation_type']))  # noqa: E501
        if 'limit' in params:
            query_params.append(('limit', params['limit']))  # noqa: E501
        if 'offset' in params:
            query_params.append(('offset', params['offset']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api_auth']  # noqa: E501

        return self.api_client.call_api(
            '/conversation/{conversation_id}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='GetMessagesByConversationIdResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_conversations(self, conversation_type, **kwargs):  # noqa: E501
        """get_conversations  # noqa: E501

        This method can be used to retrieve one or more conversations associated with a user.<br><br>The <b>conversation_type</b> query parameter is required when using this method to specify if the retrieved conversations are from eBay or from members.<br><br>The result set can also optionally be filtered by conversation status, reference, username, and/or time range. The <b>limit</b> and <b>offset</b> path parameters can be used to paginate the result set and control how many conversations are returned in the response.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_conversations(conversation_type, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str conversation_type: This query parameter specifies the type of the conversations being retrieved. Only conversations of the specified type will be returned.<br><br>This parameter is always required when using this method.<br><br><b>Valid values:</b><ul><li><code>FROM_EBAY</code></li><li><code>FROM_MEMBERS</code></li></ul> (required)
        :param str conversation_status: This query parameter specifies the status of the conversations being retrieved. Only conversations in the specified status will be returned.<br><br><b>Valid values:</b><ul><li><code>ACTIVE</code></li><li><code>ARCHIVE</code></li><li><code>DELETE</code></li><li><code>READ</code></li><li><code>UNREAD</code></li></ul>
        :param str end_time: This query parameter specifies the end time (in ISO 8601 format) for which to stop retrieving conversations.<br><br>For example, if set to <code>2024-11-06T10:00:00.000Z</code>, only messages sent before this time will be retrieved.<br><br><b>Format:</b> yyyy-MM-ddThh:mm.ss.sssZ<br><br><span class=\"tablenote\"><b>Note:</b> Currently, this parameter is only available if the <b>conversation_type</b> of the conversation is <code>FROM_MEMBERS</code>.</span>
        :param str limit: The maximum number of entries that can be returned on each page of the paginated response.<br><br>Use this parameter in conjunction with the <b>offset</b> parameter to control the pagination of the output. For example, if <b>offset</b> is set to <code>10</code> and <b>limit</b> is set to <code>10</code>, the call retrieves entries 11 through 20 from the result set.<br><br><span class=\"tablenote\"><b>Note:</b> This feature employs a zero-based list, where the first item in the list has an offset of <code>0</code>.</span><br>If this parameter is omitted, the default value is used.<br><br><b>Default:</b> 25<br><br><b>Maximum:</b> 50
        :param str offset: The number of reports to skip in the result set before returning the first entry in the paginated response.<br><br>Use this parameter in conjunction with the <b>limit</b> parameter to control the pagination of the output. For example, if <b>offset</b> is set to <code>0</code> and <b>limit</b> is set to <code>10</code>, the first page of the response will contain the first 10 entries from the complete list retrieved by the call.<br><br><span class=\"tablenote\"><b>Note:</b> This feature employs a zero-based list, where the first item in the list has an offset of <code>0</code>.</span><br>If this parameter is omitted, the default value is used.<br><br><b>Default:</b> 0
        :param str other_party_username: This query parameter specifies the user name (login name) of an eBay user for which to retrieve conversations.<br><br>If this filter is used, only conversation(s) from the other eBay user specified through this parameter will be returned. 
        :param str reference_id: This query parameter specifies the unique identifier of the reference (specified by the corresponding <b>reference_type</b> value) associated with the conversation. Only conversations associated with the specified reference ID will be returned.<br><br>For example, in the case of a <code>LISTING</code> reference, this value will be the item ID value of the listing.<br><br><span class=\"tablenote\"><b>Note:</b> If this query parameter is used, the <b>reference_type</b> parameter must also be used to specify the type of reference this ID is associated with.</span>
        :param str reference_type: This query parameter specifies the type of reference associated with a conversation.<br><br>The reference type is used to specify what the conversation is in reference to. For example, a value of <code>LISTING</code> specifies that the conversation is associated with a specific listing. The item ID associated with this listing can then be specified through the <b>reference_id</b> query parameter.<br><br>Currently, only the <code>LISTING</code> reference type is supported.
        :param str start_time: This query parameter specifies the start time (in ISO 8601 format) for which to start retrieving conversations.<br><br>For example, if set to <code>2024-11-06T10:00:00.000Z</code>, only messages sent after this time will be retrieved.<br><br><b>Format:</b> yyyy-MM-ddThh:mm.ss.sssZ<br><br><span class=\"tablenote\"><b>Note:</b> Currently, this parameter is only available if the <b>conversation_type</b> of the conversation is <code>FROM_MEMBERS</code>.</span>
        :return: GetAllMyConversationsResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        if '_return_http_data_only' not in kwargs:  # ebay_rest patch
            kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_conversations_with_http_info(conversation_type, **kwargs)  # noqa: E501
        else:
            (data) = self.get_conversations_with_http_info(conversation_type, **kwargs)  # noqa: E501
            return data

    def get_conversations_with_http_info(self, conversation_type, **kwargs):  # noqa: E501
        """get_conversations  # noqa: E501

        This method can be used to retrieve one or more conversations associated with a user.<br><br>The <b>conversation_type</b> query parameter is required when using this method to specify if the retrieved conversations are from eBay or from members.<br><br>The result set can also optionally be filtered by conversation status, reference, username, and/or time range. The <b>limit</b> and <b>offset</b> path parameters can be used to paginate the result set and control how many conversations are returned in the response.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_conversations_with_http_info(conversation_type, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str conversation_type: This query parameter specifies the type of the conversations being retrieved. Only conversations of the specified type will be returned.<br><br>This parameter is always required when using this method.<br><br><b>Valid values:</b><ul><li><code>FROM_EBAY</code></li><li><code>FROM_MEMBERS</code></li></ul> (required)
        :param str conversation_status: This query parameter specifies the status of the conversations being retrieved. Only conversations in the specified status will be returned.<br><br><b>Valid values:</b><ul><li><code>ACTIVE</code></li><li><code>ARCHIVE</code></li><li><code>DELETE</code></li><li><code>READ</code></li><li><code>UNREAD</code></li></ul>
        :param str end_time: This query parameter specifies the end time (in ISO 8601 format) for which to stop retrieving conversations.<br><br>For example, if set to <code>2024-11-06T10:00:00.000Z</code>, only messages sent before this time will be retrieved.<br><br><b>Format:</b> yyyy-MM-ddThh:mm.ss.sssZ<br><br><span class=\"tablenote\"><b>Note:</b> Currently, this parameter is only available if the <b>conversation_type</b> of the conversation is <code>FROM_MEMBERS</code>.</span>
        :param str limit: The maximum number of entries that can be returned on each page of the paginated response.<br><br>Use this parameter in conjunction with the <b>offset</b> parameter to control the pagination of the output. For example, if <b>offset</b> is set to <code>10</code> and <b>limit</b> is set to <code>10</code>, the call retrieves entries 11 through 20 from the result set.<br><br><span class=\"tablenote\"><b>Note:</b> This feature employs a zero-based list, where the first item in the list has an offset of <code>0</code>.</span><br>If this parameter is omitted, the default value is used.<br><br><b>Default:</b> 25<br><br><b>Maximum:</b> 50
        :param str offset: The number of reports to skip in the result set before returning the first entry in the paginated response.<br><br>Use this parameter in conjunction with the <b>limit</b> parameter to control the pagination of the output. For example, if <b>offset</b> is set to <code>0</code> and <b>limit</b> is set to <code>10</code>, the first page of the response will contain the first 10 entries from the complete list retrieved by the call.<br><br><span class=\"tablenote\"><b>Note:</b> This feature employs a zero-based list, where the first item in the list has an offset of <code>0</code>.</span><br>If this parameter is omitted, the default value is used.<br><br><b>Default:</b> 0
        :param str other_party_username: This query parameter specifies the user name (login name) of an eBay user for which to retrieve conversations.<br><br>If this filter is used, only conversation(s) from the other eBay user specified through this parameter will be returned. 
        :param str reference_id: This query parameter specifies the unique identifier of the reference (specified by the corresponding <b>reference_type</b> value) associated with the conversation. Only conversations associated with the specified reference ID will be returned.<br><br>For example, in the case of a <code>LISTING</code> reference, this value will be the item ID value of the listing.<br><br><span class=\"tablenote\"><b>Note:</b> If this query parameter is used, the <b>reference_type</b> parameter must also be used to specify the type of reference this ID is associated with.</span>
        :param str reference_type: This query parameter specifies the type of reference associated with a conversation.<br><br>The reference type is used to specify what the conversation is in reference to. For example, a value of <code>LISTING</code> specifies that the conversation is associated with a specific listing. The item ID associated with this listing can then be specified through the <b>reference_id</b> query parameter.<br><br>Currently, only the <code>LISTING</code> reference type is supported.
        :param str start_time: This query parameter specifies the start time (in ISO 8601 format) for which to start retrieving conversations.<br><br>For example, if set to <code>2024-11-06T10:00:00.000Z</code>, only messages sent after this time will be retrieved.<br><br><b>Format:</b> yyyy-MM-ddThh:mm.ss.sssZ<br><br><span class=\"tablenote\"><b>Note:</b> Currently, this parameter is only available if the <b>conversation_type</b> of the conversation is <code>FROM_MEMBERS</code>.</span>
        :return: GetAllMyConversationsResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['conversation_type', 'conversation_status', 'end_time', 'limit', 'offset', 'other_party_username', 'reference_id', 'reference_type', 'start_time']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_conversations" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'conversation_type' is set
        if ('conversation_type' not in params or
                params['conversation_type'] is None):
            raise ValueError("Missing the required parameter `conversation_type` when calling `get_conversations`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'conversation_status' in params:
            query_params.append(('conversation_status', params['conversation_status']))  # noqa: E501
        if 'conversation_type' in params:
            query_params.append(('conversation_type', params['conversation_type']))  # noqa: E501
        if 'end_time' in params:
            query_params.append(('end_time', params['end_time']))  # noqa: E501
        if 'limit' in params:
            query_params.append(('limit', params['limit']))  # noqa: E501
        if 'offset' in params:
            query_params.append(('offset', params['offset']))  # noqa: E501
        if 'other_party_username' in params:
            query_params.append(('other_party_username', params['other_party_username']))  # noqa: E501
        if 'reference_id' in params:
            query_params.append(('reference_id', params['reference_id']))  # noqa: E501
        if 'reference_type' in params:
            query_params.append(('reference_type', params['reference_type']))  # noqa: E501
        if 'start_time' in params:
            query_params.append(('start_time', params['start_time']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api_auth']  # noqa: E501

        return self.api_client.call_api(
            '/conversation', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='GetAllMyConversationsResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def send_message(self, content_type, **kwargs):  # noqa: E501
        """send_message  # noqa: E501

        This method can be used to start a conversation with another user or send a message in an existing conversation with another user based on the information provided in the request.<br><br>To send a message, one of the <b>conversationId</b> or <b>otherPartyUsername</b> request fields are required. The <b>conversationId</b> must be used when sending a message in an existing conversation and specifies the conversation for which to send the message. For a new conversation, the <b>otherPartyUsername</b> field must be used to send the message to a specific user. In addition, the <b>messageText</b> field is required as it contains the body text of the message.<br><br>Optionally, media (such as images or documents) can be attached to the message using the <b>messageMedia</b> container. The <b>reference</b> container can also be used to associate a message with a listing.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.send_message(content_type, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str content_type: This header indicates the format of the request body provided by the client. Its value should be set to <b>application/json</b>. <br><br>For more information, refer to <a href=\"/api-docs/static/rest-request-components.html#HTTP\" target=\"_blank \">HTTP request headers</a>. (required)
        :param SendMessageRequest body:
        :return: SendMessageResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        if '_return_http_data_only' not in kwargs:  # ebay_rest patch
            kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.send_message_with_http_info(content_type, **kwargs)  # noqa: E501
        else:
            (data) = self.send_message_with_http_info(content_type, **kwargs)  # noqa: E501
            return data

    def send_message_with_http_info(self, content_type, **kwargs):  # noqa: E501
        """send_message  # noqa: E501

        This method can be used to start a conversation with another user or send a message in an existing conversation with another user based on the information provided in the request.<br><br>To send a message, one of the <b>conversationId</b> or <b>otherPartyUsername</b> request fields are required. The <b>conversationId</b> must be used when sending a message in an existing conversation and specifies the conversation for which to send the message. For a new conversation, the <b>otherPartyUsername</b> field must be used to send the message to a specific user. In addition, the <b>messageText</b> field is required as it contains the body text of the message.<br><br>Optionally, media (such as images or documents) can be attached to the message using the <b>messageMedia</b> container. The <b>reference</b> container can also be used to associate a message with a listing.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.send_message_with_http_info(content_type, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str content_type: This header indicates the format of the request body provided by the client. Its value should be set to <b>application/json</b>. <br><br>For more information, refer to <a href=\"/api-docs/static/rest-request-components.html#HTTP\" target=\"_blank \">HTTP request headers</a>. (required)
        :param SendMessageRequest body:
        :return: SendMessageResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['content_type', 'body']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method send_message" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'content_type' is set
        if ('content_type' not in params or
                params['content_type'] is None):
            raise ValueError("Missing the required parameter `content_type` when calling `send_message`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}
        if 'content_type' in params:
            header_params['Content-Type'] = params['content_type']  # noqa: E501

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api_auth']  # noqa: E501

        return self.api_client.call_api(
            '/send_message', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='SendMessageResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def update_conversation(self, content_type, **kwargs):  # noqa: E501
        """update_conversation  # noqa: E501

        This method can be used to update the <b>conversationStatus</b> or the <b>read</b> status of a specified conversation.<br><br><span class=\"tablenote\"><b>Note:</b> Only one of these statuses can be updated at a time using this method. If both fields are included, only the <b>read</b> status of the specified conversation will be updated and the <b>conversationStatus</b> field will be ignored.</span><br>The <b>conversationId</b> of the conversation to modify, as well as the existing <b>conversationType</b> of the specified conversation are required as part of the request payload.<br><br><div class=\"msgbox_important\"><p class=\"msgbox_importantInDiv\" data-mc-autonum=\"&lt;b&gt;&lt;span style=&quot;color: #dd1e31;&quot; class=&quot;mcFormatColor&quot;&gt;Important! &lt;/span&gt;&lt;/b&gt;\"><span class=\"autonumber\"><span><b><span style=\"color: #dd1e31;\" class=\"mcFormatColor\">Important!</span></b></span></span> Though it cannot be updated, the existing <b>conversationType</b> of the specified conversation to be updated is required in the request payload. If this value is not provided, an error will occur.</p></div><br>To update a conversation's status (for example, updating an <code>ACTIVE</code> conversation to <code>ARCHIVE</code>), include the <b>conversationStatus</b> field in the request with the updated value. To update a conversation's read status (for example, updating an <code>UNREAD</code> conversation to <code>READ</code>), include the <b>read</b> boolean in the request with the updated value.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.update_conversation(content_type, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str content_type: This header indicates the format of the request body provided by the client. Its value should be set to <b>application/json</b>. <br><br>For more information, refer to <a href=\"/api-docs/static/rest-request-components.html#HTTP\" target=\"_blank \">HTTP request headers</a>. (required)
        :param UpdateConversationRequest body:
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        if '_return_http_data_only' not in kwargs:  # ebay_rest patch
            kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.update_conversation_with_http_info(content_type, **kwargs)  # noqa: E501
        else:
            (data) = self.update_conversation_with_http_info(content_type, **kwargs)  # noqa: E501
            return data

    def update_conversation_with_http_info(self, content_type, **kwargs):  # noqa: E501
        """update_conversation  # noqa: E501

        This method can be used to update the <b>conversationStatus</b> or the <b>read</b> status of a specified conversation.<br><br><span class=\"tablenote\"><b>Note:</b> Only one of these statuses can be updated at a time using this method. If both fields are included, only the <b>read</b> status of the specified conversation will be updated and the <b>conversationStatus</b> field will be ignored.</span><br>The <b>conversationId</b> of the conversation to modify, as well as the existing <b>conversationType</b> of the specified conversation are required as part of the request payload.<br><br><div class=\"msgbox_important\"><p class=\"msgbox_importantInDiv\" data-mc-autonum=\"&lt;b&gt;&lt;span style=&quot;color: #dd1e31;&quot; class=&quot;mcFormatColor&quot;&gt;Important! &lt;/span&gt;&lt;/b&gt;\"><span class=\"autonumber\"><span><b><span style=\"color: #dd1e31;\" class=\"mcFormatColor\">Important!</span></b></span></span> Though it cannot be updated, the existing <b>conversationType</b> of the specified conversation to be updated is required in the request payload. If this value is not provided, an error will occur.</p></div><br>To update a conversation's status (for example, updating an <code>ACTIVE</code> conversation to <code>ARCHIVE</code>), include the <b>conversationStatus</b> field in the request with the updated value. To update a conversation's read status (for example, updating an <code>UNREAD</code> conversation to <code>READ</code>), include the <b>read</b> boolean in the request with the updated value.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.update_conversation_with_http_info(content_type, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str content_type: This header indicates the format of the request body provided by the client. Its value should be set to <b>application/json</b>. <br><br>For more information, refer to <a href=\"/api-docs/static/rest-request-components.html#HTTP\" target=\"_blank \">HTTP request headers</a>. (required)
        :param UpdateConversationRequest body:
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['content_type', 'body']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_conversation" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'content_type' is set
        if ('content_type' not in params or
                params['content_type'] is None):
            raise ValueError("Missing the required parameter `content_type` when calling `update_conversation`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}
        if 'content_type' in params:
            header_params['Content-Type'] = params['content_type']  # noqa: E501

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api_auth']  # noqa: E501

        return self.api_client.call_api(
            '/update_conversation', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)
